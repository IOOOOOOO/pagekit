/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/views/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../node_modules/immutability-helper/index.js":
/*!********************************************************************!*\
  !*** /Domains/abz1-perm/node_modules/immutability-helper/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant = __webpack_require__(/*! invariant */ \"../../../../node_modules/invariant/browser.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), 'update(): You provided an invalid spec to update(). The spec may ' +\n                'not contain an array except as the value of $set, $push, $unshift, ' +\n                '$splice or any custom command allowing an array value.');\n        }\n        invariant(typeof spec === 'object' && spec !== null, 'update(): You provided an invalid spec to update(). The spec and ' +\n            'every included key path must be plain objects containing one of the ' +\n            'following commands: %s.', Object.keys(this.commands).join(', '));\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports.default = defaultContext.update;\n// @ts-ignore\nexports.default.default = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), 'update(): expected target of %s to be an array; got %s.', command, value);\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), 'update(): expected spec of %s to be an array; got %s. ' +\n        'Did you forget to wrap your parameter in an array?', command, spec);\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), 'Expected $splice target to be an array; got %s', value);\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), 'update(): expected spec of $splice to be an array of arrays; got %s. ' +\n        'Did you forget to wrap your parameters in an array?', value);\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', 'update(): expected spec of $apply to be a function; got %s.', fn);\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, 'Cannot have more than one key in an object with $set');\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', 'update(): $merge expects a spec of type \\'object\\'; got %s', specValue);\n    invariant(target && typeof target === 'object', 'update(): $merge expects a target of type \\'object\\'; got %s', target);\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', 'update(): %s expects a target of type Set or Map; got %s', command, typeOfTarget);\n}\n\n\n//# sourceURL=webpack:////Domains/abz1-perm/node_modules/immutability-helper/index.js?");

/***/ }),

/***/ "../../../../node_modules/invariant/browser.js":
/*!************************************************************!*\
  !*** /Domains/abz1-perm/node_modules/invariant/browser.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (true) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n//# sourceURL=webpack:////Domains/abz1-perm/node_modules/invariant/browser.js?");

/***/ }),

/***/ "../../../../node_modules/vue-nestable/dist/vue-nestable.es.js":
/*!****************************************************************************!*\
  !*** /Domains/abz1-perm/node_modules/vue-nestable/dist/vue-nestable.es.js ***!
  \****************************************************************************/
/*! exports provided: default, VueNestable, VueNestableHandle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VueNestable\", function() { return VueNestable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VueNestableHandle\", function() { return VueNestableHandle; });\n/* harmony import */ var immutability_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immutability-helper */ \"../../../../node_modules/immutability-helper/index.js\");\n/* harmony import */ var immutability_helper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(immutability_helper__WEBPACK_IMPORTED_MODULE_0__);\n/*!\n * vue-nestable v2.2.0\n * (c) 2018-present Ralph Huwiler <ralph@huwiler.rocks>\n * Released under the MIT License.\n */\n\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar store = {};\nvar groupsObserver = {\n  methods: {\n    registerNestable: function registerNestable(nestable) {\n      var storeGroup = this._getByGroup(nestable.group);\n\n      storeGroup.onDragStartListeners.push(nestable.onDragStart);\n      storeGroup.onMouseEnterListeners.push(nestable.onMouseEnter);\n      storeGroup.onMouseMoveListeners.push(nestable.onMouseMove);\n    },\n    notifyDragStart: function notifyDragStart(group, event, item) {\n      var storeGroup = this._getByGroup(group);\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = storeGroup.onDragStartListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var listener = _step.value;\n          listener(event, item);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    notifyMouseEnter: function notifyMouseEnter(group, event, eventList, item) {\n      var storeGroup = this._getByGroup(group);\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = storeGroup.onMouseEnterListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var listener = _step2.value;\n          listener(event, eventList, item);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    },\n    notifyMouseMove: function notifyMouseMove(group, event) {\n      var storeGroup = this._getByGroup(group);\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = storeGroup.onMouseMoveListeners[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var listener = _step3.value;\n          listener(event);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    },\n    _getByGroup: function _getByGroup(group) {\n      // the group already exists, return the reference\n      if (store[group]) {\n        return store[group];\n      } // otherwise create a new object for the group\n\n\n      store[group] = {\n        onDragStartListeners: [],\n        onMouseEnterListeners: [],\n        onMouseMoveListeners: [],\n        onDragStart: [],\n        dragItem: null\n      };\n      return store[group];\n    }\n  }\n};\n\nvar script = {\n  name: 'NestableItem',\n  mixins: [groupsObserver],\n  props: {\n    item: {\n      type: Object,\n      required: true,\n      default: function _default() {\n        return {};\n      }\n    },\n    index: {\n      type: Number,\n      required: false,\n      default: null\n    },\n    isChild: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    isCopy: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    options: {\n      type: Object,\n      required: true,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  inject: ['listId', 'group'],\n  data: function data() {\n    return {\n      breakPoint: null,\n      moveDown: false\n    };\n  },\n  computed: {\n    isDragging: function isDragging() {\n      var dragItem = this.options.dragItem;\n      return !this.isCopy && dragItem && dragItem[this.options.keyProp] === this.item[this.options.keyProp];\n    },\n    hasChildren: function hasChildren() {\n      return this.item[this.options.childrenProp] && this.item[this.options.childrenProp].length > 0;\n    },\n    hasHandle: function hasHandle() {\n      return !!this.$scopedSlots.handler;\n    },\n    normalizedClassProp: function normalizedClassProp() {\n      var classProp = this.item[this.options.classProp]; // if the classprop is not set, return an empty array\n\n      if (!classProp) return [];\n\n      if (Array.isArray(classProp)) {\n        return classProp;\n      } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === 'object') {\n        return [classProp];\n      } else {\n        // String value\n        return [classProp];\n      }\n    },\n    itemClasses: function itemClasses() {\n      var isDragging = this.isDragging ? ['is-dragging'] : [];\n      return [\"nestable-item\".concat(this.isCopy ? '-copy' : ''), \"nestable-item\".concat(this.isCopy ? '-copy' : '', \"-\").concat(this.item[this.options.keyProp])].concat(isDragging, _toConsumableArray(this.normalizedClassProp));\n    }\n  },\n  methods: {\n    onMouseEnter: function onMouseEnter(event) {\n      if (!this.options.dragItem) return; // if we don't know the direction the mouse is moving,\n      // we can not calculate the offset at which we should trigger a swap\n      // we we fallback to the old behavior\n\n      if (!event.movementY) {\n        return this.sendNotification(event);\n      } // when the mouse enters the item we save the size of this item\n      // is is to improve performance, so we do not recalculate the size on every move\n\n\n      this.moveDown = event.movementY > 0;\n      this.breakPoint = event.srcElement.getBoundingClientRect().height / 2;\n    },\n    onMouseLeave: function onMouseLeave() {\n      this.breakPoint = null;\n    },\n    onMouseMove: function onMouseMove(event) {\n      // if we are not in a drag operation, we can discard the input\n      if (!this.breakPoint) return; // calculate how much the mouse is away from the center\n\n      var delta = event.offsetY - this.breakPoint; // if we have not reached the breakpoint, we can abort here\n\n      if (this.moveDown && delta < this.breakPoint / 4) return;\n      if (!this.moveDown && delta > -this.breakPoint / 4) return;\n      this.sendNotification(event);\n    },\n    sendNotification: function sendNotification(event) {\n      // reset the calculated breakpoint\n      this.breakPoint = null; // and trigger the enter event\n\n      var item = this.item || this.$parent.item;\n      this.notifyMouseEnter(this.group, event, this.listId, item);\n    }\n  }\n};\n\nfunction normalizeComponent(compiledTemplate, injectStyle, defaultExport, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, isShadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n    if (typeof isShadowMode === 'function') {\n        createInjectorSSR = createInjector;\n        createInjector = isShadowMode;\n        isShadowMode = false;\n    }\n    // Vue.extend constructor export interop\n    const options = typeof defaultExport === 'function' ? defaultExport.options : defaultExport;\n    // render functions\n    if (compiledTemplate && compiledTemplate.render) {\n        options.render = compiledTemplate.render;\n        options.staticRenderFns = compiledTemplate.staticRenderFns;\n        options._compiled = true;\n        // functional template\n        if (isFunctionalTemplate) {\n            options.functional = true;\n        }\n    }\n    // scopedId\n    if (scopeId) {\n        options._scopeId = scopeId;\n    }\n    let hook;\n    if (moduleIdentifier) {\n        // server build\n        hook = function (context) {\n            // 2.3 injection\n            context =\n                context || // cached call\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\n            // 2.2 with runInNewContext: true\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n                context = __VUE_SSR_CONTEXT__;\n            }\n            // inject component styles\n            if (injectStyle) {\n                injectStyle.call(this, createInjectorSSR(context));\n            }\n            // register component module identifier for async chunk inference\n            if (context && context._registeredComponents) {\n                context._registeredComponents.add(moduleIdentifier);\n            }\n        };\n        // used by ssr in case component is cached and beforeCreate\n        // never gets called\n        options._ssrRegister = hook;\n    }\n    else if (injectStyle) {\n        hook = isShadowMode\n            ? function () {\n                injectStyle.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n            }\n            : function (context) {\n                injectStyle.call(this, createInjector(context));\n            };\n    }\n    if (hook) {\n        if (options.functional) {\n            // register for functional component in vue file\n            const originalRender = options.render;\n            options.render = function renderWithStyleInjection(h, context) {\n                hook.call(context);\n                return originalRender(h, context);\n            };\n        }\n        else {\n            // inject component registration as beforeCreate hook\n            const existing = options.beforeCreate;\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n        }\n    }\n    return defaultExport;\n}\n\n/* script */\nconst __vue_script__ = script;\n// For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258\nscript.__file = \"NestableItem.vue\";\n\n/* template */\nvar __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{class:_vm.itemClasses},[_c('div',{staticClass:\"nestable-item-content\",on:{\"mouseenter\":_vm.onMouseEnter,\"mouseleave\":_vm.onMouseLeave,\"mousemove\":_vm.onMouseMove}},[_vm._t(\"default\",null,{index:_vm.index,item:_vm.item,isChild:_vm.isChild})],2),_vm._v(\" \"),(_vm.hasChildren)?_c('ol',{staticClass:\"nestable-list\"},[_vm._l((_vm.item[_vm.options.childrenProp]),function(child,childIndex){return [_c('NestableItem',{key:childIndex,attrs:{\"index\":childIndex,\"item\":child,\"options\":_vm.options,\"is-copy\":_vm.isCopy,\"is-child\":\"\"},scopedSlots:_vm._u([_vm._l((Object.keys(_vm.$scopedSlots)),function(slot){return {key:slot,fn:function(scope){return [_vm._t(slot,null,null,scope)]}}})])})]})],2):_vm._e()])};\nvar __vue_staticRenderFns__ = [];\n\n  /* style */\n  const __vue_inject_styles__ = undefined;\n  /* scoped */\n  const __vue_scope_id__ = undefined;\n  /* module identifier */\n  const __vue_module_identifier__ = undefined;\n  /* functional template */\n  const __vue_is_functional_template__ = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n\n  \n  var NestableItem = normalizeComponent(\n    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\n    __vue_inject_styles__,\n    __vue_script__,\n    __vue_scope_id__,\n    __vue_is_functional_template__,\n    __vue_module_identifier__,\n    undefined,\n    undefined\n  );\n\n//\nvar script$1 = {\n  name: 'Placeholder',\n  mixins: [groupsObserver],\n  props: {\n    index: {\n      type: Number,\n      required: false,\n      default: null\n    },\n    options: {\n      type: Object,\n      required: false,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  inject: ['listId', 'group'],\n  computed: {\n    isDragging: function isDragging() {\n      var dragItem = this.options.dragItem;\n      return dragItem;\n    }\n  },\n  methods: {\n    onMouseEnter: function onMouseEnter(event) {\n      if (!this.options.dragItem) return;\n      this.notifyMouseEnter(this.group, event, this.listId, null);\n    }\n  }\n};\n\n/* script */\nconst __vue_script__$1 = script$1;\n// For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258\nscript$1.__file = \"Placeholder.vue\";\n\n/* template */\nvar __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',[_c('div',{staticClass:\"nestable-list-empty\",on:{\"mouseenter\":_vm.onMouseEnter}},[_vm._t(\"default\")],2)])};\nvar __vue_staticRenderFns__$1 = [];\n\n  /* style */\n  const __vue_inject_styles__$1 = undefined;\n  /* scoped */\n  const __vue_scope_id__$1 = undefined;\n  /* module identifier */\n  const __vue_module_identifier__$1 = undefined;\n  /* functional template */\n  const __vue_is_functional_template__$1 = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n\n  \n  var Placeholder = normalizeComponent(\n    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },\n    __vue_inject_styles__$1,\n    __vue_script__$1,\n    __vue_scope_id__$1,\n    __vue_is_functional_template__$1,\n    __vue_module_identifier__$1,\n    undefined,\n    undefined\n  );\n\nvar nestableHelpers = {\n  methods: {\n    // ––––––––––––––––––––––––––––––––––––\n    // Getter methods\n    // ––––––––––––––––––––––––––––––––––––\n    getPathById: function getPathById(id) {\n      var _this = this;\n\n      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value;\n      var path = [];\n      items.every(function (item, i) {\n        if (item[_this.keyProp] === id) {\n          path.push(i);\n        } else if (item[_this.childrenProp]) {\n          var childrenPath = _this.getPathById(id, item[_this.childrenProp]);\n\n          if (childrenPath.length) {\n            path = path.concat(i).concat(childrenPath);\n          }\n        }\n\n        return path.length === 0;\n      });\n      return path;\n    },\n    getItemByPath: function getItemByPath(path) {\n      var _this2 = this;\n\n      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value;\n      var item = null;\n      path.forEach(function (index) {\n        var list = item && item[_this2.childrenProp] ? item[_this2.childrenProp] : items;\n        item = list[index];\n      });\n      return item;\n    },\n    getItemDepth: function getItemDepth(item) {\n      var level = 1;\n\n      if (item[this.childrenProp] && item[this.childrenProp].length > 0) {\n        var childrenDepths = item[this.childrenProp].map(this.getItemDepth);\n        level += Math.max.apply(Math, _toConsumableArray(childrenDepths));\n      }\n\n      return level;\n    },\n    getSplicePath: function getSplicePath(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var splicePath = {};\n      var numToRemove = options.numToRemove || 0;\n      var itemsToInsert = options.itemsToInsert || [];\n      var lastIndex = path.length - 1;\n      var currentPath = splicePath;\n      path.forEach(function (index, i) {\n        if (i === lastIndex) {\n          currentPath.$splice = [[index, numToRemove].concat(_toConsumableArray(itemsToInsert))];\n        } else {\n          var nextPath = {};\n          currentPath[index] = _defineProperty({}, options.childrenProp, nextPath);\n          currentPath = nextPath;\n        }\n      });\n      return splicePath;\n    },\n    getRealNextPath: function getRealNextPath(prevPath, nextPath) {\n      var ppLastIndex = prevPath.length - 1;\n      var npLastIndex = nextPath.length - 1;\n\n      if (prevPath.length < nextPath.length) {\n        // move into deep\n        var wasShifted = false;\n        return nextPath.map(function (nextIndex, i) {\n          if (wasShifted) {\n            return i === npLastIndex ? nextIndex + 1 : nextIndex;\n          }\n\n          if (typeof prevPath[i] !== 'number') {\n            return nextIndex;\n          }\n\n          if (nextPath[i] > prevPath[i] && i === ppLastIndex) {\n            wasShifted = true;\n            return nextIndex - 1;\n          }\n\n          return nextIndex;\n        });\n      } else if (prevPath.length === nextPath.length) {\n        // if move bottom + move to item with children => make it a first child instead of swap\n        if (nextPath[npLastIndex] > prevPath[npLastIndex]) {\n          var target = this.getItemByPath(nextPath);\n\n          if (target[this.childrenProp] && target[this.childrenProp].length && !this.isCollapsed(target)) {\n            return nextPath.slice(0, -1).concat(nextPath[npLastIndex] - 1).concat(0);\n          }\n        }\n      }\n\n      return nextPath;\n    } // getItemOptions() {\n    //   const { renderItem, renderCollapseIcon, handler, childrenProp } = this.props;\n    //   const { dragItem } = this.state;\n    //   return {\n    //     dragItem,\n    //     childrenProp,\n    //     renderItem,\n    //     renderCollapseIcon,\n    //     handler,\n    //     onDragStart: this.onDragStart,\n    //     onMouseEnter: this.onMouseEnter,\n    //     isCollapsed: this.isCollapsed,\n    //     onToggleCollapse: this.onToggleCollapse\n    //   };\n    // }\n\n  }\n};\n\nvar closest = function closest(target, selector) {\n  return target.closest(selector);\n};\nvar getOffsetRect = function getOffsetRect(elem) {\n  var box = elem.getBoundingClientRect();\n  return {\n    top: Math.round(box.top),\n    left: Math.round(box.left)\n  };\n};\nvar getTransformProps = function getTransformProps(x, y) {\n  return {\n    transform: 'translate(' + x + 'px, ' + y + 'px)'\n  };\n};\nvar listWithChildren = function listWithChildren(list, childrenProp) {\n  return list.map(function (item) {\n    return _objectSpread({}, item, _defineProperty({}, childrenProp, item[childrenProp] ? listWithChildren(item[childrenProp], childrenProp) : []));\n  });\n};\n\nvar script$2 = {\n  name: 'VueNestable',\n  components: {\n    NestableItem: NestableItem,\n    Placeholder: Placeholder\n  },\n  mixins: [nestableHelpers, groupsObserver],\n  props: {\n    value: {\n      type: Array,\n      required: true,\n      default: function _default() {\n        return [];\n      }\n    },\n    threshold: {\n      type: Number,\n      required: false,\n      default: 30\n    },\n    maxDepth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    keyProp: {\n      type: String,\n      required: false,\n      default: 'id'\n    },\n    classProp: {\n      type: String,\n      required: false,\n      default: null\n    },\n    group: {\n      type: [String, Number],\n      required: false,\n      default: function _default() {\n        return Math.random().toString(36).slice(2);\n      }\n    },\n    childrenProp: {\n      type: String,\n      required: false,\n      default: 'children'\n    },\n    collapsed: {\n      type: Boolean,\n      required: false,\n      default: false\n    }\n  },\n  provide: function provide() {\n    return {\n      listId: this.listId,\n      group: this.group,\n      onDragEnd: this.onDragEnd\n    };\n  },\n  data: function data() {\n    return {\n      itemsOld: null,\n      // revert to copy in case of cancelling drag\n      dragItem: null,\n      mouse: {\n        last: {\n          x: 0\n        },\n        shift: {\n          x: 0\n        }\n      },\n      el: null,\n      elCopyStyles: null,\n      isDirty: false,\n      collapsedGroups: [],\n      listId: Math.random().toString(36).slice(2)\n    };\n  },\n  computed: {\n    listIsEmpty: function listIsEmpty() {\n      return this.value.length === 0;\n    },\n    itemOptions: function itemOptions() {\n      return {\n        dragItem: this.dragItem,\n        keyProp: this.keyProp,\n        classProp: this.classProp,\n        childrenProp: this.childrenProp\n      };\n    },\n    listStyles: function listStyles() {\n      var el = document.querySelector('.nestable-' + this.group + ' .nestable-item-' + this.dragItem[this.keyProp]);\n      var listStyles = {};\n\n      if (el) {\n        listStyles.width = \"\".concat(el.clientWidth, \"px\");\n      }\n\n      if (this.elCopyStyles) {\n        listStyles = _objectSpread({}, listStyles, this.elCopyStyles);\n      }\n\n      return listStyles;\n    }\n  },\n  created: function created() {\n    var items = listWithChildren(this.value, this.childrenProp);\n    this.$emit('input', items);\n    this.isDirty = false;\n    this.registerNestable(this);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.stopTrackMouse();\n  },\n  methods: {\n    startTrackMouse: function startTrackMouse() {\n      document.addEventListener('mousemove', this.onMouseMove);\n      document.addEventListener('mouseup', this.onDragEnd);\n      document.addEventListener('touchend', this.onDragEnd);\n      document.addEventListener('touchcancel', this.onDragEnd);\n      document.addEventListener('keydown', this.onKeyDown);\n    },\n    stopTrackMouse: function stopTrackMouse() {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onDragEnd);\n      document.removeEventListener('touchend', this.onDragEnd);\n      document.removeEventListener('touchcancel', this.onDragEnd);\n      document.removeEventListener('keydown', this.onKeyDown);\n      this.elCopyStyles = null;\n    },\n    onDragStart: function onDragStart(event, item) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      this.el = closest(event.target, '.nestable-item');\n      this.startTrackMouse();\n      this.dragItem = item;\n      this.itemsOld = this.value;\n      this.onMouseMove(event);\n    },\n    onDragEnd: function onDragEnd(event, isCancel) {\n      event && event.preventDefault();\n      this.stopTrackMouse();\n      this.el = null;\n      isCancel ? this.dragRevert() : this.dragApply();\n    },\n    onKeyDown: function onKeyDown(event) {\n      if (event.which === 27) {\n        // ESC\n        this.onDragEnd(null, true);\n      }\n    },\n    getXandYFromEvent: function getXandYFromEvent(event) {\n      var clientX = event.clientX,\n          clientY = event.clientY; // get touch event\n\n      var targetTouches = event.targetTouches; // if there is a touch event, use this\n\n      if (targetTouches) {\n        var touch = targetTouches[0];\n        clientX = touch.clientX;\n        clientY = touch.clientY; // we rely on the mouseenter event to track if a node should be moved\n        // since this event does not exist, we need to simulate it.\n\n        var _event = new Event('mouseenter');\n\n        var element = document.elementFromPoint(clientX, clientY);\n        var touchElement = element && (element.closest('.nestable-item-content') || element.closest('.nestable-list-empty'));\n        if (touchElement) touchElement.dispatchEvent(_event);\n      }\n\n      return {\n        clientX: clientX,\n        clientY: clientY\n      };\n    },\n    onMouseMove: function onMouseMove(event) {\n      var _this$getXandYFromEve = this.getXandYFromEvent(event),\n          clientX = _this$getXandYFromEve.clientX,\n          clientY = _this$getXandYFromEve.clientY;\n\n      var transformProps = getTransformProps(clientX, clientY);\n      var elCopy = document.querySelector('.nestable-' + this.group + ' .nestable-drag-layer > .nestable-list');\n\n      if (!this.elCopyStyles) {\n        var offset = getOffsetRect(this.el);\n        this.elCopyStyles = _objectSpread({\n          marginTop: \"\".concat(offset.top - clientY, \"px\"),\n          marginLeft: \"\".concat(offset.left - clientX, \"px\")\n        }, transformProps);\n      } else {\n        this.elCopyStyles = _objectSpread({}, this.elCopyStyles, transformProps);\n\n        if (elCopy) {\n          for (var key in transformProps) {\n            if (transformProps.hasOwnProperty(key)) {\n              elCopy.style[key] = transformProps[key];\n            }\n          }\n        }\n\n        var diffX = clientX - this.mouse.last.x;\n\n        if (diffX >= 0 && this.mouse.shift.x >= 0 || diffX <= 0 && this.mouse.shift.x <= 0) {\n          this.mouse.shift.x += diffX;\n        } else {\n          this.mouse.shift.x = 0;\n        }\n\n        this.mouse.last.x = clientX;\n\n        if (Math.abs(this.mouse.shift.x) > this.threshold) {\n          if (this.mouse.shift.x > 0) {\n            this.tryIncreaseDepth(this.dragItem);\n          } else {\n            this.tryDecreaseDepth(this.dragItem);\n          }\n\n          this.mouse.shift.x = 0;\n        }\n      }\n    },\n    moveItem: function moveItem(_ref) {\n      var dragItem = _ref.dragItem,\n          pathFrom = _ref.pathFrom,\n          pathTo = _ref.pathTo;\n      // the remove action might affect the next position,\n      // so update next coordinates accordingly\n      var realPathTo = this.getRealNextPath(pathFrom, pathTo);\n      var removePath = this.getSplicePath(pathFrom, {\n        numToRemove: 1,\n        childrenProp: this.childrenProp\n      });\n      var insertPath = this.getSplicePath(realPathTo, {\n        numToRemove: 0,\n        itemsToInsert: [dragItem],\n        childrenProp: this.childrenProp\n      });\n      var items = this.value;\n      items = immutability_helper__WEBPACK_IMPORTED_MODULE_0___default()(items, removePath);\n      items = immutability_helper__WEBPACK_IMPORTED_MODULE_0___default()(items, insertPath);\n      this.isDirty = true;\n      this.pathTo = pathTo;\n      this.$emit('input', items);\n    },\n    tryIncreaseDepth: function tryIncreaseDepth(dragItem) {\n      var pathFrom = this.getPathById(dragItem[this.keyProp]);\n      var itemIndex = pathFrom[pathFrom.length - 1];\n      var newDepth = pathFrom.length + this.getItemDepth(dragItem); // has previous sibling and isn't at max depth\n\n      if (itemIndex > 0 && newDepth <= this.maxDepth) {\n        var prevSibling = this.getItemByPath(pathFrom.slice(0, -1).concat(itemIndex - 1)); // previous sibling is not collapsed\n\n        if (prevSibling[this.childrenProp] && (!prevSibling[this.childrenProp].length || !this.isCollapsed(prevSibling))) {\n          var pathTo = pathFrom.slice(0, -1).concat(itemIndex - 1).concat(prevSibling[this.childrenProp].length); // if collapsed by default\n          // and was no children here\n          // open this node\n          // let collapseProps = {};\n          // if (collapsed && !prevSibling[this.childrenProp].length) {\n          //   collapseProps = this.onToggleCollapse(prevSibling, true);\n          // }\n          // this.moveItem({ dragItem, pathFrom, pathTo }, collapseProps)\n\n          this.moveItem({\n            dragItem: dragItem,\n            pathFrom: pathFrom,\n            pathTo: pathTo\n          });\n        }\n      }\n    },\n    tryDecreaseDepth: function tryDecreaseDepth(dragItem) {\n      var pathFrom = this.getPathById(dragItem[this.keyProp]);\n      var itemIndex = pathFrom[pathFrom.length - 1]; // has parent\n\n      if (pathFrom.length > 1) {\n        var parent = this.getItemByPath(pathFrom.slice(0, -1)); // is last (by order) item in array\n\n        if (itemIndex + 1 === parent[this.childrenProp].length) {\n          var pathTo = pathFrom.slice(0, -1);\n          pathTo[pathTo.length - 1] += 1; // if collapsed by default\n          // and is last (by count) item in array\n          // remove this node from list of open nodes\n          // let collapseProps = {};\n          // if (collapsed && parent[this.childrenProp].length == 1) {\n          //   collapseProps = this.onToggleCollapse(parent, true);\n          // }\n          // this.moveItem({ dragItem, pathFrom, pathTo }, collapseProps)\n\n          this.moveItem({\n            dragItem: dragItem,\n            pathFrom: pathFrom,\n            pathTo: pathTo\n          });\n        }\n      }\n    },\n    onMouseEnter: function onMouseEnter(event, eventList, item) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      var dragItem = this.dragItem; // if the event does not have a valid item that belongs to this list, ignore it\n\n      if (item !== null && dragItem[this.keyProp] === item[this.keyProp]) return; // calculate the path the item is comming from\n\n      var pathFrom = this.getPathById(dragItem[this.keyProp]); // if the event is not emitted from this list and the item was not removed from this list,\n      // we can ignore this event\n\n      if (eventList !== this.listId && pathFrom.length === 0) return;\n      var pathTo; // if we are dragging to an empty list, we need to remove\n      // the item from the origin list and append it to the start of the new list\n\n      if (item === null) {\n        pathTo = pathFrom.length > 0 ? [] : [0];\n      } else {\n        pathTo = this.getPathById(item[this.keyProp]);\n      } // if the move to the new depth is greater than max depth,\n      // don't move\n\n\n      var newDepth = this.getRealNextPath(pathFrom, pathTo).length + (this.getItemDepth(dragItem) - 1);\n\n      if (newDepth > this.maxDepth) {\n        return;\n      } // if collapsed by default\n      // and move last (by count) child\n      // remove parent node from list of open nodes\n\n\n      var collapseProps = {};\n\n      if (this.collapsed && pathFrom.length > 1) {\n        var parent = this.getItemByPath(pathFrom.slice(0, -1));\n\n        if (parent[this.childrenProp].length === 1) {\n          collapseProps = this.onToggleCollapse(parent, true);\n        }\n      }\n\n      this.moveItem({\n        dragItem: dragItem,\n        pathFrom: pathFrom,\n        pathTo: pathTo\n      }, collapseProps);\n    },\n    isCollapsed: function isCollapsed(item) {\n      return !!(this.collapsedGroups.indexOf(item[this.keyProp]) > -1 ^ this.collapsed);\n    },\n    dragApply: function dragApply() {\n      this.$emit('change', this.dragItem, {\n        pathTo: this.pathTo\n      });\n      this.pathTo = null;\n      this.itemsOld = null;\n      this.dragItem = null;\n      this.isDirty = false;\n    },\n    dragRevert: function dragRevert() {\n      this.$emit('input', this.itemsOld);\n      this.pathTo = null;\n      this.itemsOld = null;\n      this.dragItem = null;\n      this.isDirty = false;\n    }\n  }\n};\n\n/* script */\nconst __vue_script__$2 = script$2;\n// For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258\nscript$2.__file = \"VueNestable.vue\";\n\n/* template */\nvar __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:['nestable', (\"nestable-\" + _vm.group)]},[_c('ol',{staticClass:\"nestable-list nestable-group\"},[(_vm.listIsEmpty)?_c('Placeholder',{attrs:{\"options\":_vm.itemOptions}},[_vm._t(\"placeholder\",[_vm._v(\"\\n        No content\\n      \")])],2):_vm._e(),_vm._v(\" \"),_vm._l((_vm.value),function(item,index){return [_c('NestableItem',{key:index,attrs:{\"index\":index,\"item\":item,\"options\":_vm.itemOptions},scopedSlots:_vm._u([_vm._l((Object.keys(_vm.$scopedSlots)),function(slot){return {key:slot,fn:function(scope){return [_vm._t(slot,null,null,scope)]}}})])})]})],2),_vm._v(\" \"),(_vm.dragItem)?[_c('div',{staticClass:\"nestable-drag-layer\"},[_c('ol',{staticClass:\"nestable-list\",style:(_vm.listStyles)},[_c('NestableItem',{attrs:{\"item\":_vm.dragItem,\"options\":_vm.itemOptions,\"is-copy\":true},scopedSlots:_vm._u([_vm._l((Object.keys(_vm.$scopedSlots)),function(slot){return {key:slot,fn:function(scope){return [_vm._t(slot,null,null,scope)]}}})])})],1)])]:_vm._e()],2)};\nvar __vue_staticRenderFns__$2 = [];\n\n  /* style */\n  const __vue_inject_styles__$2 = undefined;\n  /* scoped */\n  const __vue_scope_id__$2 = undefined;\n  /* module identifier */\n  const __vue_module_identifier__$2 = undefined;\n  /* functional template */\n  const __vue_is_functional_template__$2 = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n\n  \n  var VueNestable = normalizeComponent(\n    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },\n    __vue_inject_styles__$2,\n    __vue_script__$2,\n    __vue_scope_id__$2,\n    __vue_is_functional_template__$2,\n    __vue_module_identifier__$2,\n    undefined,\n    undefined\n  );\n\n//\nvar script$3 = {\n  name: 'VueNestableHandle',\n  mixins: [groupsObserver],\n  props: {\n    item: {\n      type: Object,\n      required: false,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  inject: ['group', 'onDragEnd'],\n  methods: {\n    dragstart: function dragstart(event) {\n      var item = this.item || this.$parent.item;\n      this.notifyDragStart(this.group, event, item);\n    },\n    touchend: function touchend(event) {\n      this.onDragEnd(event);\n    },\n    touchmove: function touchmove(event) {\n      this.notifyMouseMove(this.group, event);\n    }\n  }\n};\n\n/* script */\nconst __vue_script__$3 = script$3;\n// For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258\nscript$3.__file = \"VueNestableHandle.vue\";\n\n/* template */\nvar __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"nestable-handle\",attrs:{\"draggable\":\"\"},on:{\"dragstart\":_vm.dragstart,\"touchstart\":_vm.dragstart,\"touchend\":_vm.touchend,\"touchmove\":_vm.touchmove}},[_vm._t(\"default\")],2)};\nvar __vue_staticRenderFns__$3 = [];\n\n  /* style */\n  const __vue_inject_styles__$3 = undefined;\n  /* scoped */\n  const __vue_scope_id__$3 = undefined;\n  /* module identifier */\n  const __vue_module_identifier__$3 = undefined;\n  /* functional template */\n  const __vue_is_functional_template__$3 = false;\n  /* style inject */\n  \n  /* style inject SSR */\n  \n\n  \n  var VueNestableHandle = normalizeComponent(\n    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },\n    __vue_inject_styles__$3,\n    __vue_script__$3,\n    __vue_scope_id__$3,\n    __vue_is_functional_template__$3,\n    __vue_module_identifier__$3,\n    undefined,\n    undefined\n  );\n\nvar index = {\n  install: function install(Vue, options) {\n    Vue.component('VueNestable', VueNestable);\n    Vue.component('VueNestableHandle', VueNestableHandle);\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n\n\n//# sourceURL=webpack:////Domains/abz1-perm/node_modules/vue-nestable/dist/vue-nestable.es.js?");

/***/ }),

/***/ "./app/views/index.js":
/*!****************************!*\
  !*** ./app/views/index.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var uikit_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uikit-util */ \"uikit-util\");\n/* harmony import */ var uikit_util__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(uikit_util__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vue_nestable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-nestable */ \"../../../../node_modules/vue-nestable/dist/vue-nestable.es.js\");\n\n\n\n// device detection\nwindow.isMobile = false; // initiate as false\nif (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)\n    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(navigator.userAgent.substr(0, 4))) { window.isMobile = true; }\nconst is_iPad = navigator.userAgent.match(/iPad/i) != null;\nif (is_iPad) { window.isMobile = true; }\n\nVue.ready({\n\n    name: 'site',\n\n    el: '#site',\n\n    mixins: [Vue2Filters.mixin],\n\n    data() {\n        return _.merge({\n            edit: {}, // undefined,\n            menu: this.$session.get('site.menu', {}),\n            menus: [],\n            nodes: [],\n            treedata: [],\n            selected: [],\n        }, window.$data);\n    },\n\n    created() {\n        this.Menus = this.$resource('api/site/menu{/id}');\n        this.Nodes = this.$resource('api/site/node{/id}');\n\n        const vm = this;\n        this.load().then(() => {\n            vm.$set(vm, 'menu', _.find(vm.menus, { id: vm.menu.id }) || vm.menus[0]);\n        });\n\n        this.$watch(vm => (vm.menu, vm.nodes, Date.now()), () => {\n            this.tree('update');\n        }, { deep: true });\n\n        Object(uikit_util__WEBPACK_IMPORTED_MODULE_0__[\"on\"])(window, 'resize', () => {\n            this.propWidth();\n        });\n    },\n\n    mounted() {},\n\n    methods: {\n\n        propWidth() {\n            Object(uikit_util__WEBPACK_IMPORTED_MODULE_0__[\"css\"])(this.$refs['table-header'], {\n                minWidth: '100%',\n                width: this.$refs.nestable.$el.offsetWidth ? this.$refs.nestable.$el.offsetWidth : '100%',\n                opacity: '1',\n            });\n        },\n\n        change(value, options) {\n            if (!options || !options.pathTo) return;\n\n            const vm = this;\n\n            var updateTree = (tree, parent_id) => {\n                _.forEach(tree, (item, id) => {\n                    item.priority = id;\n                    item.parent_id = parent_id;\n                    if (item.children.length) updateTree(item.children, item.id);\n                });\n            };\n\n            updateTree(this.treedata, 0);\n\n            vm.Nodes.save({ id: 'updateOrder' }, {\n                menu: vm.menu.id,\n                nodes: vm.tree('flatten'), // vm.nestableList(this.treedata)\n            }).then(vm.load, () => {\n                vm.$notify('Reorder failed.', 'danger');\n            });\n        },\n\n        tree(...args) {\n            const [fn, ...props] = arguments; const vm = this;\n            const methods = {\n                unflatten() {\n                    let [array, parent, tree] = arguments; const\n                        self = this;\n\n                    tree = typeof tree !== 'undefined' ? tree : [];\n                    parent = typeof parent !== 'undefined' ? parent : { id: 0 };\n\n                    const children = _.filter(array, child => child.parent_id == parent.id);\n\n                    if (!_.isEmpty(children)) {\n                        if (parent.id == 0) {\n                            tree = children;\n                        } else {\n                            parent.children = children;\n                        }\n                        _.each(children, (child) => { self.unflatten(array, child); });\n                    }\n\n                    return tree;\n                },\n                flatten() {\n                    const treeStructure = { children: vm.treedata };\n\n                    const flatten = (children, extractChildren, level, order) => Array.prototype.concat.apply(\n                        children.map(x => ({ ...x, level: level || 1, order: x.priority || 0 })),\n                        children.map(x => flatten(extractChildren(x) || [], extractChildren, (level || 1) + 1)),\n                    );\n\n                    const extractChildren = x => x.children;\n\n                    const flat = flatten(extractChildren(treeStructure), extractChildren).map(x => delete x.children && x);\n\n                    return flat;\n                },\n                update() {\n                    let nodes = vm.nodes.map((entry) => { entry.class = 'check-item'; return entry; });\n                    nodes = _(nodes).filter({ menu: vm.menu.id }).sortBy('priority').value();\n                    vm.treedata = this.unflatten(nodes);\n                    vm.$nextTick(() => {\n                        vm.propWidth();\n                    });\n                },\n            };\n\n            return methods[fn] && (typeof methods[fn] === 'function') ? methods[fn](props) : false;\n        },\n\n        load() {\n            const vm = this;\n            return Vue.Promise.all([\n                this.Menus.query(),\n                this.Nodes.query(),\n            ]).then((responses) => {\n                vm.$set(vm, 'menus', responses[0].data);\n                vm.$set(vm, 'nodes', responses[1].data);\n                vm.$set(vm, 'selected', []);\n\n                if (!_.find(vm.menus, { id: vm.menu.id })) {\n                    vm.$set(vm, 'menu', vm.menus[0]);\n                }\n            }, () => {\n                vm.$notify('Loading failed.', 'danger');\n            });\n        },\n\n        isActive(menu) {\n            return this.menu && this.menu.id === menu.id;\n        },\n\n        selectMenu(menu) {\n            this.$set(this, 'selected', []);\n            this.$set(this, 'menu', menu);\n            this.$session.set('site.menu', menu);\n        },\n\n        removeMenu(e, menu) {\n            this.Menus.delete({ id: menu.id }).finally(this.load);\n        },\n\n        editMenu(e, menu) {\n            if (!menu) {\n                menu = {\n                    id: '',\n                    label: '',\n                };\n            }\n\n            this.$set(this, 'edit', _.merge({ positions: [] }, menu));\n            this.$refs.modal.open();\n        },\n\n        saveMenu(menu) {\n            this.Menus.save({ menu }).then(this.load, function (res) {\n                this.$notify(res.data, 'danger');\n            });\n\n            this.cancel();\n        },\n\n        getMenu(position) {\n            return _.find(this.menus, menu => _.includes(menu.positions, position));\n        },\n\n        cancel() {\n            this.$refs.modal.close();\n        },\n\n        status(status) {\n            const nodes = this.getSelected();\n\n            nodes.forEach((node) => {\n                node.status = status;\n            });\n\n            this.Nodes.save({ id: 'bulk' }, { nodes }).then(function () {\n                this.load();\n                this.$notify('Page(s) saved.');\n            });\n        },\n\n        moveNodes(menu) {\n            const vm = this;\n            const nodes = this.getSelected();\n\n            var updateChilds = function (node) {\n                _.forEach(node.children, (item) => {\n                    const search = _.filter(nodes, e => e.id == item.id);\n                    if (!search.length) {\n                        const key = Object.keys(vm.nodes).find(key => vm.nodes[key].id === item.id);\n                        vm.nodes[key].parent_id = null;\n                        nodes.push(vm.nodes[key]);\n                    }\n                    if (item.children) updateChilds(item);\n                });\n            };\n\n            nodes.forEach((node) => {\n                node.parent_id = null;\n                node.menu = menu;\n                updateChilds(node);\n            });\n\n            this.Nodes.save({ id: 'bulk' }, { nodes }).then(function () {\n                this.load();\n                this.$notify(this.$trans('Pages moved to %menu%.', {\n                    menu: _.find(this.menus.concat({\n                        id: 'trash',\n                        label: this.$trans('Trash'),\n                    }), { 'id': menu}).label,\n                }));\n            });\n        },\n\n        removeNodes() {\n            if (this.menu.id !== 'trash') {\n                const nodes = this.getSelected();\n\n                nodes.forEach((node) => {\n                    node.status = 0;\n                });\n\n                this.moveNodes('trash');\n            } else {\n                this.Nodes.delete({ id: 'bulk' }, { ids: this.selected }).then(function () {\n                    this.load();\n                    this.$notify('Page(s) deleted.');\n                });\n            }\n        },\n\n        getType(node) {\n            return _.find(this.types, { id: node.type });\n        },\n\n        getSelected() {\n            return this.nodes.filter(function (node) {\n                return this.isSelected(node);\n            }, this);\n        },\n\n        isSelected(node, children) {\n            const vm = this;\n            if (_.isArray(node)) {\n                return _.every(node, node => vm.isSelected(node, children), this);\n            }\n\n            return this.selected.indexOf(node.id) !== -1 && (!children || !this.tree[node.id] || this.isSelected(this.tree[node.id], true));\n        },\n\n        toggleSelect(node) {\n            const index = this.selected.indexOf(node.id);\n\n            if (index == -1) {\n                this.selected.push(node.id);\n            } else {\n                this.selected.splice(index, 1);\n            }\n        },\n\n        label(id) {\n            return _.result(_.find(this.menus, 'id', id), 'label');\n        },\n\n        protected(types) {\n            return _.reject(types, { protected: true });\n        },\n\n        trash(menus) {\n            return _.reject(menus, { id: 'trash' });\n        },\n\n        divided(menus) {\n            return _.reject(menus, { fixed: true }).concat({ divider: true }, _.filter(menus, { fixed: true }));\n        },\n\n        menuLabel(id) {\n            return this.$trans('(Currently set to: %menu%)', { menu: this.label(id) });\n        },\n\n        isFrontpage(node) {\n            return node.url === '/';\n        },\n\n        type(node) {\n            return this.getType(node) || {};\n        },\n\n        setFrontpage(node) {\n            this.Nodes.save({ id: 'frontpage' }, { id: node.id }).then(function () {\n                this.load();\n                this.$notify('Frontpage updated.');\n            });\n        },\n\n        toggleStatus(node) {\n            node.status = node.status === 1 ? 0 : 1;\n\n            this.Nodes.save({ id: node.id }, { node }).then(function () {\n                this.load();\n                this.$notify('Page saved.');\n            });\n        },\n\n    },\n\n    computed: {\n\n        showDelete() {\n            const vm = this;\n            return this.showMove && _.every(this.getSelected(), node => !(vm.getType(node) || {}).protected, this);\n        },\n\n        showMove() {\n            return this.isSelected(this.getSelected(), true);\n        },\n\n        isMobile() {\n            return window.isMobile;\n        },\n    },\n\n    components: {\n        VueNestable: vue_nestable__WEBPACK_IMPORTED_MODULE_1__[\"VueNestable\"],\n        VueNestableHandle: vue_nestable__WEBPACK_IMPORTED_MODULE_1__[\"VueNestableHandle\"],\n    },\n\n});\n\n\n//# sourceURL=webpack:///./app/views/index.js?");

/***/ }),

/***/ "uikit-util":
/*!*****************************!*\
  !*** external "UIkit.util" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = UIkit.util;\n\n//# sourceURL=webpack:///external_%22UIkit.util%22?");

/***/ })

/******/ });